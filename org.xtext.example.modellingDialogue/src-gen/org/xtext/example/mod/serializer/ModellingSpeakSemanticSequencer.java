/*
 * generated by Xtext 2.35.0
 */
package org.xtext.example.mod.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.mod.modellingSpeak.AttackExperiment;
import org.xtext.example.mod.modellingSpeak.AttackModel;
import org.xtext.example.mod.modellingSpeak.AttackRequirement;
import org.xtext.example.mod.modellingSpeak.CounterModel;
import org.xtext.example.mod.modellingSpeak.Experiment;
import org.xtext.example.mod.modellingSpeak.Game;
import org.xtext.example.mod.modellingSpeak.Model;
import org.xtext.example.mod.modellingSpeak.ModellingSpeakPackage;
import org.xtext.example.mod.modellingSpeak.NotConvinced;
import org.xtext.example.mod.modellingSpeak.ProposeExperiment;
import org.xtext.example.mod.modellingSpeak.ProposeModel;
import org.xtext.example.mod.modellingSpeak.ProposeRequirement;
import org.xtext.example.mod.modellingSpeak.RedefineRequirement;
import org.xtext.example.mod.modellingSpeak.ReplaceModel;
import org.xtext.example.mod.modellingSpeak.Requirement;
import org.xtext.example.mod.modellingSpeak.RetractExperiment;
import org.xtext.example.mod.modellingSpeak.RetractRequirement;
import org.xtext.example.mod.modellingSpeak.ReviseRequirement;
import org.xtext.example.mod.modellingSpeak.StudyDone;
import org.xtext.example.mod.modellingSpeak.SupportExperiment;
import org.xtext.example.mod.modellingSpeak.SupportModel;
import org.xtext.example.mod.modellingSpeak.SupportRequirement;
import org.xtext.example.mod.modellingSpeak.Theory;
import org.xtext.example.mod.services.ModellingSpeakGrammarAccess;

@SuppressWarnings("all")
public class ModellingSpeakSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private ModellingSpeakGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == ModellingSpeakPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ModellingSpeakPackage.ATTACK_EXPERIMENT:
				sequence_AttackExperiment(context, (AttackExperiment) semanticObject); 
				return; 
			case ModellingSpeakPackage.ATTACK_MODEL:
				sequence_AttackModel(context, (AttackModel) semanticObject); 
				return; 
			case ModellingSpeakPackage.ATTACK_REQUIREMENT:
				sequence_AttackRequirement(context, (AttackRequirement) semanticObject); 
				return; 
			case ModellingSpeakPackage.COUNTER_MODEL:
				sequence_CounterModel(context, (CounterModel) semanticObject); 
				return; 
			case ModellingSpeakPackage.EXPERIMENT:
				sequence_Experiment(context, (Experiment) semanticObject); 
				return; 
			case ModellingSpeakPackage.GAME:
				sequence_Game(context, (Game) semanticObject); 
				return; 
			case ModellingSpeakPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case ModellingSpeakPackage.NOT_CONVINCED:
				sequence_NotConvinced(context, (NotConvinced) semanticObject); 
				return; 
			case ModellingSpeakPackage.PROPOSE_EXPERIMENT:
				sequence_ProposeExperiment(context, (ProposeExperiment) semanticObject); 
				return; 
			case ModellingSpeakPackage.PROPOSE_MODEL:
				sequence_ProposeModel(context, (ProposeModel) semanticObject); 
				return; 
			case ModellingSpeakPackage.PROPOSE_REQUIREMENT:
				sequence_ProposeRequirement(context, (ProposeRequirement) semanticObject); 
				return; 
			case ModellingSpeakPackage.REDEFINE_REQUIREMENT:
				sequence_RedefineRequirement(context, (RedefineRequirement) semanticObject); 
				return; 
			case ModellingSpeakPackage.REPLACE_MODEL:
				sequence_ReplaceModel(context, (ReplaceModel) semanticObject); 
				return; 
			case ModellingSpeakPackage.REQUIREMENT:
				sequence_Requirement(context, (Requirement) semanticObject); 
				return; 
			case ModellingSpeakPackage.RETRACT_EXPERIMENT:
				sequence_RetractExperiment(context, (RetractExperiment) semanticObject); 
				return; 
			case ModellingSpeakPackage.RETRACT_REQUIREMENT:
				sequence_RetractRequirement(context, (RetractRequirement) semanticObject); 
				return; 
			case ModellingSpeakPackage.REVISE_REQUIREMENT:
				sequence_ReviseRequirement(context, (ReviseRequirement) semanticObject); 
				return; 
			case ModellingSpeakPackage.STUDY_DONE:
				sequence_StudyDone(context, (StudyDone) semanticObject); 
				return; 
			case ModellingSpeakPackage.SUPPORT_EXPERIMENT:
				sequence_SupportExperiment(context, (SupportExperiment) semanticObject); 
				return; 
			case ModellingSpeakPackage.SUPPORT_MODEL:
				sequence_SupportModel(context, (SupportModel) semanticObject); 
				return; 
			case ModellingSpeakPackage.SUPPORT_REQUIREMENT:
				sequence_SupportRequirement(context, (SupportRequirement) semanticObject); 
				return; 
			case ModellingSpeakPackage.THEORY:
				sequence_Theory(context, (Theory) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Move returns AttackExperiment
	 *     AttackExperiment returns AttackExperiment
	 *
	 * Constraint:
	 *     (experiment=[Experiment|ID] theory=Theory)
	 * </pre>
	 */
	protected void sequence_AttackExperiment(ISerializationContext context, AttackExperiment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModellingSpeakPackage.Literals.ATTACK_EXPERIMENT__EXPERIMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModellingSpeakPackage.Literals.ATTACK_EXPERIMENT__EXPERIMENT));
			if (transientValues.isValueTransient(semanticObject, ModellingSpeakPackage.Literals.ATTACK_EXPERIMENT__THEORY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModellingSpeakPackage.Literals.ATTACK_EXPERIMENT__THEORY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAttackExperimentAccess().getExperimentExperimentIDTerminalRuleCall_2_0_1(), semanticObject.eGet(ModellingSpeakPackage.Literals.ATTACK_EXPERIMENT__EXPERIMENT, false));
		feeder.accept(grammarAccess.getAttackExperimentAccess().getTheoryTheoryParserRuleCall_4_0(), semanticObject.getTheory());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Move returns AttackModel
	 *     AttackModel returns AttackModel
	 *
	 * Constraint:
	 *     (model=[Model|ID] theory=Theory)
	 * </pre>
	 */
	protected void sequence_AttackModel(ISerializationContext context, AttackModel semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModellingSpeakPackage.Literals.ATTACK_MODEL__MODEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModellingSpeakPackage.Literals.ATTACK_MODEL__MODEL));
			if (transientValues.isValueTransient(semanticObject, ModellingSpeakPackage.Literals.ATTACK_MODEL__THEORY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModellingSpeakPackage.Literals.ATTACK_MODEL__THEORY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAttackModelAccess().getModelModelIDTerminalRuleCall_2_0_1(), semanticObject.eGet(ModellingSpeakPackage.Literals.ATTACK_MODEL__MODEL, false));
		feeder.accept(grammarAccess.getAttackModelAccess().getTheoryTheoryParserRuleCall_4_0(), semanticObject.getTheory());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Move returns AttackRequirement
	 *     AttackRequirement returns AttackRequirement
	 *
	 * Constraint:
	 *     (requirement=[Requirement|ID] theory=Theory)
	 * </pre>
	 */
	protected void sequence_AttackRequirement(ISerializationContext context, AttackRequirement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModellingSpeakPackage.Literals.ATTACK_REQUIREMENT__REQUIREMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModellingSpeakPackage.Literals.ATTACK_REQUIREMENT__REQUIREMENT));
			if (transientValues.isValueTransient(semanticObject, ModellingSpeakPackage.Literals.ATTACK_REQUIREMENT__THEORY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModellingSpeakPackage.Literals.ATTACK_REQUIREMENT__THEORY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAttackRequirementAccess().getRequirementRequirementIDTerminalRuleCall_2_0_1(), semanticObject.eGet(ModellingSpeakPackage.Literals.ATTACK_REQUIREMENT__REQUIREMENT, false));
		feeder.accept(grammarAccess.getAttackRequirementAccess().getTheoryTheoryParserRuleCall_4_0(), semanticObject.getTheory());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Move returns CounterModel
	 *     CounterModel returns CounterModel
	 *
	 * Constraint:
	 *     (model=[Model|ID] experiment=Experiment requirement=[Requirement|ID])
	 * </pre>
	 */
	protected void sequence_CounterModel(ISerializationContext context, CounterModel semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModellingSpeakPackage.Literals.COUNTER_MODEL__MODEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModellingSpeakPackage.Literals.COUNTER_MODEL__MODEL));
			if (transientValues.isValueTransient(semanticObject, ModellingSpeakPackage.Literals.COUNTER_MODEL__EXPERIMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModellingSpeakPackage.Literals.COUNTER_MODEL__EXPERIMENT));
			if (transientValues.isValueTransient(semanticObject, ModellingSpeakPackage.Literals.COUNTER_MODEL__REQUIREMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModellingSpeakPackage.Literals.COUNTER_MODEL__REQUIREMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCounterModelAccess().getModelModelIDTerminalRuleCall_2_0_1(), semanticObject.eGet(ModellingSpeakPackage.Literals.COUNTER_MODEL__MODEL, false));
		feeder.accept(grammarAccess.getCounterModelAccess().getExperimentExperimentParserRuleCall_4_0(), semanticObject.getExperiment());
		feeder.accept(grammarAccess.getCounterModelAccess().getRequirementRequirementIDTerminalRuleCall_6_0_1(), semanticObject.eGet(ModellingSpeakPackage.Literals.COUNTER_MODEL__REQUIREMENT, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Experiment returns Experiment
	 *
	 * Constraint:
	 *     (name=ID content=STRING)
	 * </pre>
	 */
	protected void sequence_Experiment(ISerializationContext context, Experiment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModellingSpeakPackage.Literals.EXPERIMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModellingSpeakPackage.Literals.EXPERIMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, ModellingSpeakPackage.Literals.EXPERIMENT__CONTENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModellingSpeakPackage.Literals.EXPERIMENT__CONTENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExperimentAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getExperimentAccess().getContentSTRINGTerminalRuleCall_2_0(), semanticObject.getContent());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Game returns Game
	 *
	 * Constraint:
	 *     moves+=Move+
	 * </pre>
	 */
	protected void sequence_Game(ISerializationContext context, Game semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (name=ID content=STRING)
	 * </pre>
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModellingSpeakPackage.Literals.MODEL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModellingSpeakPackage.Literals.MODEL__NAME));
			if (transientValues.isValueTransient(semanticObject, ModellingSpeakPackage.Literals.MODEL__CONTENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModellingSpeakPackage.Literals.MODEL__CONTENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getModelAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getModelAccess().getContentSTRINGTerminalRuleCall_2_0(), semanticObject.getContent());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Move returns NotConvinced
	 *     NotConvinced returns NotConvinced
	 *
	 * Constraint:
	 *     model=[Model|ID]
	 * </pre>
	 */
	protected void sequence_NotConvinced(ISerializationContext context, NotConvinced semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModellingSpeakPackage.Literals.NOT_CONVINCED__MODEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModellingSpeakPackage.Literals.NOT_CONVINCED__MODEL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNotConvincedAccess().getModelModelIDTerminalRuleCall_2_0_1(), semanticObject.eGet(ModellingSpeakPackage.Literals.NOT_CONVINCED__MODEL, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Move returns ProposeExperiment
	 *     ProposeExperiment returns ProposeExperiment
	 *
	 * Constraint:
	 *     (model=[Model|ID] experiment=Experiment requirement=[Requirement|ID])
	 * </pre>
	 */
	protected void sequence_ProposeExperiment(ISerializationContext context, ProposeExperiment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModellingSpeakPackage.Literals.PROPOSE_EXPERIMENT__MODEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModellingSpeakPackage.Literals.PROPOSE_EXPERIMENT__MODEL));
			if (transientValues.isValueTransient(semanticObject, ModellingSpeakPackage.Literals.PROPOSE_EXPERIMENT__EXPERIMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModellingSpeakPackage.Literals.PROPOSE_EXPERIMENT__EXPERIMENT));
			if (transientValues.isValueTransient(semanticObject, ModellingSpeakPackage.Literals.PROPOSE_EXPERIMENT__REQUIREMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModellingSpeakPackage.Literals.PROPOSE_EXPERIMENT__REQUIREMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProposeExperimentAccess().getModelModelIDTerminalRuleCall_2_0_1(), semanticObject.eGet(ModellingSpeakPackage.Literals.PROPOSE_EXPERIMENT__MODEL, false));
		feeder.accept(grammarAccess.getProposeExperimentAccess().getExperimentExperimentParserRuleCall_4_0(), semanticObject.getExperiment());
		feeder.accept(grammarAccess.getProposeExperimentAccess().getRequirementRequirementIDTerminalRuleCall_6_0_1(), semanticObject.eGet(ModellingSpeakPackage.Literals.PROPOSE_EXPERIMENT__REQUIREMENT, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Move returns ProposeModel
	 *     ProposeModel returns ProposeModel
	 *
	 * Constraint:
	 *     (model=Model requirement=[Requirement|ID])
	 * </pre>
	 */
	protected void sequence_ProposeModel(ISerializationContext context, ProposeModel semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModellingSpeakPackage.Literals.PROPOSE_MODEL__MODEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModellingSpeakPackage.Literals.PROPOSE_MODEL__MODEL));
			if (transientValues.isValueTransient(semanticObject, ModellingSpeakPackage.Literals.PROPOSE_MODEL__REQUIREMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModellingSpeakPackage.Literals.PROPOSE_MODEL__REQUIREMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProposeModelAccess().getModelModelParserRuleCall_2_0(), semanticObject.getModel());
		feeder.accept(grammarAccess.getProposeModelAccess().getRequirementRequirementIDTerminalRuleCall_4_0_1(), semanticObject.eGet(ModellingSpeakPackage.Literals.PROPOSE_MODEL__REQUIREMENT, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Move returns ProposeRequirement
	 *     ProposeRequirement returns ProposeRequirement
	 *
	 * Constraint:
	 *     requirement=Requirement
	 * </pre>
	 */
	protected void sequence_ProposeRequirement(ISerializationContext context, ProposeRequirement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModellingSpeakPackage.Literals.PROPOSE_REQUIREMENT__REQUIREMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModellingSpeakPackage.Literals.PROPOSE_REQUIREMENT__REQUIREMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProposeRequirementAccess().getRequirementRequirementParserRuleCall_2_0(), semanticObject.getRequirement());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Move returns RedefineRequirement
	 *     RedefineRequirement returns RedefineRequirement
	 *
	 * Constraint:
	 *     (requirement=[Requirement|ID] newRequirement=Requirement)
	 * </pre>
	 */
	protected void sequence_RedefineRequirement(ISerializationContext context, RedefineRequirement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModellingSpeakPackage.Literals.REDEFINE_REQUIREMENT__REQUIREMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModellingSpeakPackage.Literals.REDEFINE_REQUIREMENT__REQUIREMENT));
			if (transientValues.isValueTransient(semanticObject, ModellingSpeakPackage.Literals.REDEFINE_REQUIREMENT__NEW_REQUIREMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModellingSpeakPackage.Literals.REDEFINE_REQUIREMENT__NEW_REQUIREMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRedefineRequirementAccess().getRequirementRequirementIDTerminalRuleCall_2_0_1(), semanticObject.eGet(ModellingSpeakPackage.Literals.REDEFINE_REQUIREMENT__REQUIREMENT, false));
		feeder.accept(grammarAccess.getRedefineRequirementAccess().getNewRequirementRequirementParserRuleCall_4_0(), semanticObject.getNewRequirement());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Move returns ReplaceModel
	 *     ReplaceModel returns ReplaceModel
	 *
	 * Constraint:
	 *     (model=[Model|ID] newModel=Model)
	 * </pre>
	 */
	protected void sequence_ReplaceModel(ISerializationContext context, ReplaceModel semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModellingSpeakPackage.Literals.REPLACE_MODEL__MODEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModellingSpeakPackage.Literals.REPLACE_MODEL__MODEL));
			if (transientValues.isValueTransient(semanticObject, ModellingSpeakPackage.Literals.REPLACE_MODEL__NEW_MODEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModellingSpeakPackage.Literals.REPLACE_MODEL__NEW_MODEL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReplaceModelAccess().getModelModelIDTerminalRuleCall_2_0_1(), semanticObject.eGet(ModellingSpeakPackage.Literals.REPLACE_MODEL__MODEL, false));
		feeder.accept(grammarAccess.getReplaceModelAccess().getNewModelModelParserRuleCall_4_0(), semanticObject.getNewModel());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Requirement returns Requirement
	 *
	 * Constraint:
	 *     (name=ID content=STRING)
	 * </pre>
	 */
	protected void sequence_Requirement(ISerializationContext context, Requirement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModellingSpeakPackage.Literals.REQUIREMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModellingSpeakPackage.Literals.REQUIREMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, ModellingSpeakPackage.Literals.REQUIREMENT__CONTENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModellingSpeakPackage.Literals.REQUIREMENT__CONTENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRequirementAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getRequirementAccess().getContentSTRINGTerminalRuleCall_2_0(), semanticObject.getContent());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Move returns RetractExperiment
	 *     RetractExperiment returns RetractExperiment
	 *
	 * Constraint:
	 *     experiment=[Experiment|ID]
	 * </pre>
	 */
	protected void sequence_RetractExperiment(ISerializationContext context, RetractExperiment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModellingSpeakPackage.Literals.RETRACT_EXPERIMENT__EXPERIMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModellingSpeakPackage.Literals.RETRACT_EXPERIMENT__EXPERIMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRetractExperimentAccess().getExperimentExperimentIDTerminalRuleCall_2_0_1(), semanticObject.eGet(ModellingSpeakPackage.Literals.RETRACT_EXPERIMENT__EXPERIMENT, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Move returns RetractRequirement
	 *     RetractRequirement returns RetractRequirement
	 *
	 * Constraint:
	 *     requirement=[Requirement|ID]
	 * </pre>
	 */
	protected void sequence_RetractRequirement(ISerializationContext context, RetractRequirement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModellingSpeakPackage.Literals.RETRACT_REQUIREMENT__REQUIREMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModellingSpeakPackage.Literals.RETRACT_REQUIREMENT__REQUIREMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRetractRequirementAccess().getRequirementRequirementIDTerminalRuleCall_2_0_1(), semanticObject.eGet(ModellingSpeakPackage.Literals.RETRACT_REQUIREMENT__REQUIREMENT, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Move returns ReviseRequirement
	 *     ReviseRequirement returns ReviseRequirement
	 *
	 * Constraint:
	 *     (model=[Model|ID] requirement=[Requirement|ID] newRequirement=Requirement experiment=[Experiment|ID])
	 * </pre>
	 */
	protected void sequence_ReviseRequirement(ISerializationContext context, ReviseRequirement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModellingSpeakPackage.Literals.REVISE_REQUIREMENT__MODEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModellingSpeakPackage.Literals.REVISE_REQUIREMENT__MODEL));
			if (transientValues.isValueTransient(semanticObject, ModellingSpeakPackage.Literals.REVISE_REQUIREMENT__REQUIREMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModellingSpeakPackage.Literals.REVISE_REQUIREMENT__REQUIREMENT));
			if (transientValues.isValueTransient(semanticObject, ModellingSpeakPackage.Literals.REVISE_REQUIREMENT__NEW_REQUIREMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModellingSpeakPackage.Literals.REVISE_REQUIREMENT__NEW_REQUIREMENT));
			if (transientValues.isValueTransient(semanticObject, ModellingSpeakPackage.Literals.REVISE_REQUIREMENT__EXPERIMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModellingSpeakPackage.Literals.REVISE_REQUIREMENT__EXPERIMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReviseRequirementAccess().getModelModelIDTerminalRuleCall_2_0_1(), semanticObject.eGet(ModellingSpeakPackage.Literals.REVISE_REQUIREMENT__MODEL, false));
		feeder.accept(grammarAccess.getReviseRequirementAccess().getRequirementRequirementIDTerminalRuleCall_4_0_1(), semanticObject.eGet(ModellingSpeakPackage.Literals.REVISE_REQUIREMENT__REQUIREMENT, false));
		feeder.accept(grammarAccess.getReviseRequirementAccess().getNewRequirementRequirementParserRuleCall_6_0(), semanticObject.getNewRequirement());
		feeder.accept(grammarAccess.getReviseRequirementAccess().getExperimentExperimentIDTerminalRuleCall_8_0_1(), semanticObject.eGet(ModellingSpeakPackage.Literals.REVISE_REQUIREMENT__EXPERIMENT, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Move returns StudyDone
	 *     StudyDone returns StudyDone
	 *
	 * Constraint:
	 *     {StudyDone}
	 * </pre>
	 */
	protected void sequence_StudyDone(ISerializationContext context, StudyDone semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Move returns SupportExperiment
	 *     SupportExperiment returns SupportExperiment
	 *
	 * Constraint:
	 *     (experiment=[Experiment|ID] theory=Theory)
	 * </pre>
	 */
	protected void sequence_SupportExperiment(ISerializationContext context, SupportExperiment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModellingSpeakPackage.Literals.SUPPORT_EXPERIMENT__EXPERIMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModellingSpeakPackage.Literals.SUPPORT_EXPERIMENT__EXPERIMENT));
			if (transientValues.isValueTransient(semanticObject, ModellingSpeakPackage.Literals.SUPPORT_EXPERIMENT__THEORY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModellingSpeakPackage.Literals.SUPPORT_EXPERIMENT__THEORY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSupportExperimentAccess().getExperimentExperimentIDTerminalRuleCall_2_0_1(), semanticObject.eGet(ModellingSpeakPackage.Literals.SUPPORT_EXPERIMENT__EXPERIMENT, false));
		feeder.accept(grammarAccess.getSupportExperimentAccess().getTheoryTheoryParserRuleCall_4_0(), semanticObject.getTheory());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Move returns SupportModel
	 *     SupportModel returns SupportModel
	 *
	 * Constraint:
	 *     (model=[Model|ID] theory=Theory)
	 * </pre>
	 */
	protected void sequence_SupportModel(ISerializationContext context, SupportModel semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModellingSpeakPackage.Literals.SUPPORT_MODEL__MODEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModellingSpeakPackage.Literals.SUPPORT_MODEL__MODEL));
			if (transientValues.isValueTransient(semanticObject, ModellingSpeakPackage.Literals.SUPPORT_MODEL__THEORY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModellingSpeakPackage.Literals.SUPPORT_MODEL__THEORY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSupportModelAccess().getModelModelIDTerminalRuleCall_2_0_1(), semanticObject.eGet(ModellingSpeakPackage.Literals.SUPPORT_MODEL__MODEL, false));
		feeder.accept(grammarAccess.getSupportModelAccess().getTheoryTheoryParserRuleCall_4_0(), semanticObject.getTheory());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Move returns SupportRequirement
	 *     SupportRequirement returns SupportRequirement
	 *
	 * Constraint:
	 *     (requirement=[Requirement|ID] theory=Theory)
	 * </pre>
	 */
	protected void sequence_SupportRequirement(ISerializationContext context, SupportRequirement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModellingSpeakPackage.Literals.SUPPORT_REQUIREMENT__REQUIREMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModellingSpeakPackage.Literals.SUPPORT_REQUIREMENT__REQUIREMENT));
			if (transientValues.isValueTransient(semanticObject, ModellingSpeakPackage.Literals.SUPPORT_REQUIREMENT__THEORY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModellingSpeakPackage.Literals.SUPPORT_REQUIREMENT__THEORY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSupportRequirementAccess().getRequirementRequirementIDTerminalRuleCall_2_0_1(), semanticObject.eGet(ModellingSpeakPackage.Literals.SUPPORT_REQUIREMENT__REQUIREMENT, false));
		feeder.accept(grammarAccess.getSupportRequirementAccess().getTheoryTheoryParserRuleCall_4_0(), semanticObject.getTheory());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Theory returns Theory
	 *
	 * Constraint:
	 *     (name=ID content=STRING)
	 * </pre>
	 */
	protected void sequence_Theory(ISerializationContext context, Theory semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModellingSpeakPackage.Literals.THEORY__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModellingSpeakPackage.Literals.THEORY__NAME));
			if (transientValues.isValueTransient(semanticObject, ModellingSpeakPackage.Literals.THEORY__CONTENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModellingSpeakPackage.Literals.THEORY__CONTENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTheoryAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getTheoryAccess().getContentSTRINGTerminalRuleCall_2_0(), semanticObject.getContent());
		feeder.finish();
	}
	
	
}
