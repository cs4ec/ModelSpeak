/*
 * generated by Xtext 2.35.0
 */
package org.xtext.example.mod.generator

import java.util.HashMap
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.eclipse.xtext.resource.SaveOptions
import org.xtext.example.mod.modellingSpeak.AttackExperiment
import org.xtext.example.mod.modellingSpeak.AttackModel
import org.xtext.example.mod.modellingSpeak.AttackRequirement
import org.xtext.example.mod.modellingSpeak.CounterModel
import org.xtext.example.mod.modellingSpeak.Game
import org.xtext.example.mod.modellingSpeak.NotConvinced
import org.xtext.example.mod.modellingSpeak.ProposeExperiment
import org.xtext.example.mod.modellingSpeak.ProposeModel
import org.xtext.example.mod.modellingSpeak.ProposeRequirement
import org.xtext.example.mod.modellingSpeak.RedefineRequirement
import org.xtext.example.mod.modellingSpeak.ReplaceModel
import org.xtext.example.mod.modellingSpeak.RetractExperiment
import org.xtext.example.mod.modellingSpeak.RetractRequirement
import org.xtext.example.mod.modellingSpeak.SupportExperiment
import org.xtext.example.mod.modellingSpeak.SupportModel
import org.xtext.example.mod.modellingSpeak.SupportRequirement
import org.xtext.example.modellingDialogue.theoryStore.Experiment
import org.xtext.example.modellingDialogue.theoryStore.Model
import org.xtext.example.modellingDialogue.theoryStore.Requirement
import org.xtext.example.modellingDialogue.theoryStore.Theory
import org.xtext.example.modellingDialogue.theoryStore.TheoryStoreFactory

class ModellingSpeakGenerator extends AbstractGenerator {
	val extension TheoryStoreFactory factory = TheoryStoreFactory.eINSTANCE

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		resource.contents.forEach [ e |
			if (e instanceof Game) {
				generateTheoryStore(e as Game, resource, fsa)
			}
		]
	}

	def generateTheoryStore(Game game, Resource resource, IFileSystemAccess2 fsa) {
		val theoryStore = createTheoryStore

		val requirementMap = new HashMap<String, Requirement>()
		val modelMap = new HashMap<String, Model>()
		val experimentMap = new HashMap<String, Experiment>()
		val theoryMap = new HashMap<String, Theory>()

		// Can split this out into dispatch methods - perhaps need to make the maps a member of the class
		game.moves.forEach [ move |

			// --------------- Requirement -----------------
			if (move instanceof ProposeRequirement) {
				val req = factory.createRequirement
				req.name = move.requirement.name
				req.content = move.requirement.content
				requirementMap.put(req.name, req)
				theoryStore.elements += req

			} else if (move instanceof AttackRequirement) {
				val theory = factory.createTheory
				theory.name = move.theory.name
				theory.content = move.theory.getContent()
				if (move.requirement.name !== null) {
					theory.elements += experimentMap.get(move.requirement.name)
				}
				theoryMap.put(theory.name, theory)
				theoryStore.elements += theory

			} else if (move instanceof RedefineRequirement) {
				val newReq = factory.createRequirement
				newReq.name = move.newRequirement.name
				newReq.content = move.newRequirement.getContent()
				if (move.requirement.name !== null) {
					val oldReq = requirementMap.remove(move.requirement.name)

					// Traverse all models that reference the old requirement, and update them to reference the new requirement
					modelMap.values.forEach [ model |
						if (model.requirements.contains(oldReq)) {
							model.requirements.remove(oldReq)
							model.requirements.add(newReq)
						}
					]

					// Remove all Theory that referenced the deleted Requirement
					val theoriesToRemove = theoryStore.elements.filter(Theory).filter [ theory |
						theory.elements.contains(oldReq)
					]
					theoriesToRemove.forEach [ theory |
						theoryStore.elements.remove(theory)
					]

					theoryStore.elements.remove(move.requirement.name)
				}
				requirementMap.put(newReq.name, newReq)
				theoryStore.elements += newReq

			} else if (move instanceof RetractRequirement) {
				if (move.requirement.name !== null) {
					requirementMap.remove(move.requirement.name)

					// Remove all Theory that referenced the deleted Requirement
					val theoriesToRemove = theoryStore.elements.filter(Theory).filter [ theory |
						theory.elements.contains(move.requirement)
					]
					theoriesToRemove.forEach [ theory |
						theoryStore.elements.remove(theory)
					]

					theoryStore.elements.remove(move.requirement.name)
				}

			} else if (move instanceof SupportRequirement) {
				val theory = factory.createTheory
				theory.name = move.theory.name
				theory.content = move.theory.getContent()
				if (move.requirement.name !== null) {
					theory.elements += requirementMap.get(move.requirement.name)
				}
				theoryMap.put(theory.name, theory)
				theoryStore.elements += theory

			// --------------- Model -----------------
			} else if (move instanceof ProposeModel) {
				val mdl = factory.createModel
				mdl.name = move.model.name
				mdl.content = move.model.content
				if (move.requirement.name !== null) {
					mdl.requirements += requirementMap.get(move.requirement.name)
				}
				modelMap.put(mdl.name, mdl)
				theoryStore.elements += mdl

			} else if (move instanceof SupportModel) {
				val theory = factory.createTheory
				theory.name = move.theory.name
				theory.content = move.theory.getContent()
				if (move.model.name !== null) {
					theory.elements += modelMap.get(move.model.name)
				}
				theoryMap.put(theory.name, theory)
				theoryStore.elements += theory

			} else if (move instanceof ReplaceModel) {
				val newModel = factory.createModel
				newModel.name = move.newModel.name
				newModel.content = move.newModel.getContent()

				if (move.model.name !== null) {
					val oldModel = modelMap.get(move.model.name)
					if (oldModel !== null) {
						// Transfer the requirements from the old model to the new model
						newModel.requirements.addAll(oldModel.requirements)

						// Collect theories to remove
						val theoriesToRemove = theoryStore.elements.filter(Theory).filter [ theory |
							theory.elements.contains(oldModel)
						].toList

						// Collect experiments to remove
						val experimentsToRemove = theoryStore.elements.filter(Experiment).filter [ experiment |
							experiment.model.contains(oldModel)
						].toList

						// Remove the collected theories and experiments
						theoriesToRemove.forEach [ theory |
							theoryStore.elements.remove(theory)
						]

						experimentsToRemove.forEach [ experiment |
							theoryStore.elements.remove(experiment)
						]

						// Remove the old model from the map and the theory store
						modelMap.remove(move.model.name)
						theoryStore.elements.remove(oldModel)
					} else {
						println("Old model not found for name: " + move.model.name)
					}
				} else {
					println("Move model name is null")
				}

				// Add the new model to the map and the theory store
				modelMap.put(newModel.name, newModel)
				theoryStore.elements += newModel

			} else if (move instanceof CounterModel) {
				val experiment = factory.createExperiment
				experiment.name = move.experiment.name
				experiment.content = move.experiment.getContent()
				if (move.model.name !== null) {
					experiment.model += modelMap.get(move.model.name)
				}
				if (move.requirement.name !== null) {
					experiment.requirements += requirementMap.get(move.requirement.name)
				}
				experimentMap.put(experiment.name, experiment)
				theoryStore.elements += experiment

			} else if (move instanceof AttackModel) {
				val theory = factory.createTheory
				theory.name = move.theory.name
				theory.content = move.theory.getContent()
				if (move.model.name !== null) {
					theory.elements += modelMap.get(move.model.name)
				}
				theoryMap.put(theory.name, theory)
				theoryStore.elements += theory

			// --------------- Experiment -----------------
			} else if (move instanceof ProposeExperiment) {
				val exp = factory.createExperiment
				exp.name = move.experiment.name
				exp.content = move.experiment.content
				if (move.model.name !== null) {
					exp.model += modelMap.get(move.model.name)
				}
				if (move.requirement.name !== null) {
					exp.requirements += requirementMap.get(move.requirement.name)
				}
				experimentMap.put(exp.name, exp)
				theoryStore.elements += exp

			} else if (move instanceof SupportExperiment) {
				val theory = factory.createTheory
				theory.name = move.theory.name
				theory.content = move.theory.getContent()
				if (move.experiment.name !== null) {
					theory.elements += experimentMap.get(move.experiment.name)
				}
				theoryMap.put(theory.name, theory)
				theoryStore.elements += theory

			} else if (move instanceof AttackExperiment) {
				val theory = factory.createTheory
				theory.name = move.theory.name
				theory.content = move.theory.getContent()
				if (move.experiment.name !== null) {
					theory.elements += experimentMap.get(move.experiment.name)
				}
				theoryMap.put(theory.name, theory)
				theoryStore.elements += theory

			} else if (move instanceof RetractExperiment) {
				if (move.experiment.name !== null) {
					experimentMap.remove(move.experiment.name)
					theoryStore.elements.remove(move.experiment.name)
				}

			} else if (move instanceof NotConvinced) {
				val theory = factory.createTheory
				theory.name = "NoConfidence"
				theory.content = "No confidence in model " + (move as NotConvinced).model.name
				if ((move as NotConvinced).model.name !== null) {
					theory.elements += modelMap.get((move as NotConvinced).model.name)
				}
				theoryStore.elements += theory
			}
		]

		val outputUri = fsa.getURI("theoryStoreOutput.theoryStore")
		val resourceSet = resource.resourceSet
		val newResource = resourceSet.createResource(outputUri)
		newResource.contents += theoryStore
		newResource.save(SaveOptions.newBuilder().format().getOptions().toOptionsMap())
	}
}
