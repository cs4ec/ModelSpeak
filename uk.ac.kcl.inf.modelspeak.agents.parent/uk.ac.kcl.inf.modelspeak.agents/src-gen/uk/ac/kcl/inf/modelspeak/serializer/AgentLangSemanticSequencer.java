/*
 * generated by Xtext 2.35.0
 */
package uk.ac.kcl.inf.modelspeak.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import uk.ac.kcl.inf.modelspeak.agentLang.AgentLangPackage;
import uk.ac.kcl.inf.modelspeak.agentLang.AttackExperiment;
import uk.ac.kcl.inf.modelspeak.agentLang.AttackModel;
import uk.ac.kcl.inf.modelspeak.agentLang.AttackRequirement;
import uk.ac.kcl.inf.modelspeak.agentLang.CounterModel;
import uk.ac.kcl.inf.modelspeak.agentLang.Experiment;
import uk.ac.kcl.inf.modelspeak.agentLang.Game;
import uk.ac.kcl.inf.modelspeak.agentLang.GeneralTheory;
import uk.ac.kcl.inf.modelspeak.agentLang.LiteratureReference;
import uk.ac.kcl.inf.modelspeak.agentLang.Model;
import uk.ac.kcl.inf.modelspeak.agentLang.NotConvinced;
import uk.ac.kcl.inf.modelspeak.agentLang.ProposeExperiment;
import uk.ac.kcl.inf.modelspeak.agentLang.ProposeModel;
import uk.ac.kcl.inf.modelspeak.agentLang.ProposeRQ;
import uk.ac.kcl.inf.modelspeak.agentLang.ProposeRequirement;
import uk.ac.kcl.inf.modelspeak.agentLang.RedefineRequirement;
import uk.ac.kcl.inf.modelspeak.agentLang.ReplaceModel;
import uk.ac.kcl.inf.modelspeak.agentLang.Requirement;
import uk.ac.kcl.inf.modelspeak.agentLang.ResearchQuestion;
import uk.ac.kcl.inf.modelspeak.agentLang.RetractExperiment;
import uk.ac.kcl.inf.modelspeak.agentLang.RetractRequirement;
import uk.ac.kcl.inf.modelspeak.agentLang.ReviseRequirement;
import uk.ac.kcl.inf.modelspeak.agentLang.StudyDone;
import uk.ac.kcl.inf.modelspeak.agentLang.SupportExperiment;
import uk.ac.kcl.inf.modelspeak.agentLang.SupportModel;
import uk.ac.kcl.inf.modelspeak.agentLang.SupportRequirement;
import uk.ac.kcl.inf.modelspeak.services.AgentLangGrammarAccess;

@SuppressWarnings("all")
public class AgentLangSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private AgentLangGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == AgentLangPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case AgentLangPackage.ATTACK_EXPERIMENT:
				sequence_AttackExperiment(context, (AttackExperiment) semanticObject); 
				return; 
			case AgentLangPackage.ATTACK_MODEL:
				sequence_AttackModel(context, (AttackModel) semanticObject); 
				return; 
			case AgentLangPackage.ATTACK_REQUIREMENT:
				sequence_AttackRequirement(context, (AttackRequirement) semanticObject); 
				return; 
			case AgentLangPackage.COUNTER_MODEL:
				sequence_CounterModel(context, (CounterModel) semanticObject); 
				return; 
			case AgentLangPackage.EXPERIMENT:
				sequence_Experiment(context, (Experiment) semanticObject); 
				return; 
			case AgentLangPackage.GAME:
				sequence_Game(context, (Game) semanticObject); 
				return; 
			case AgentLangPackage.GENERAL_THEORY:
				sequence_GeneralTheory(context, (GeneralTheory) semanticObject); 
				return; 
			case AgentLangPackage.LITERATURE_REFERENCE:
				sequence_LiteratureReference(context, (LiteratureReference) semanticObject); 
				return; 
			case AgentLangPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case AgentLangPackage.NOT_CONVINCED:
				sequence_NotConvinced(context, (NotConvinced) semanticObject); 
				return; 
			case AgentLangPackage.PROPOSE_EXPERIMENT:
				sequence_ProposeExperiment(context, (ProposeExperiment) semanticObject); 
				return; 
			case AgentLangPackage.PROPOSE_MODEL:
				sequence_ProposeModel(context, (ProposeModel) semanticObject); 
				return; 
			case AgentLangPackage.PROPOSE_RQ:
				sequence_ProposeRQ(context, (ProposeRQ) semanticObject); 
				return; 
			case AgentLangPackage.PROPOSE_REQUIREMENT:
				sequence_ProposeRequirement(context, (ProposeRequirement) semanticObject); 
				return; 
			case AgentLangPackage.REDEFINE_REQUIREMENT:
				sequence_RedefineRequirement(context, (RedefineRequirement) semanticObject); 
				return; 
			case AgentLangPackage.REPLACE_MODEL:
				sequence_ReplaceModel(context, (ReplaceModel) semanticObject); 
				return; 
			case AgentLangPackage.REQUIREMENT:
				sequence_Requirement(context, (Requirement) semanticObject); 
				return; 
			case AgentLangPackage.RESEARCH_QUESTION:
				sequence_ResearchQuestion(context, (ResearchQuestion) semanticObject); 
				return; 
			case AgentLangPackage.RETRACT_EXPERIMENT:
				sequence_RetractExperiment(context, (RetractExperiment) semanticObject); 
				return; 
			case AgentLangPackage.RETRACT_REQUIREMENT:
				sequence_RetractRequirement(context, (RetractRequirement) semanticObject); 
				return; 
			case AgentLangPackage.REVISE_REQUIREMENT:
				sequence_ReviseRequirement(context, (ReviseRequirement) semanticObject); 
				return; 
			case AgentLangPackage.STUDY_DONE:
				sequence_StudyDone(context, (StudyDone) semanticObject); 
				return; 
			case AgentLangPackage.SUPPORT_EXPERIMENT:
				sequence_SupportExperiment(context, (SupportExperiment) semanticObject); 
				return; 
			case AgentLangPackage.SUPPORT_MODEL:
				sequence_SupportModel(context, (SupportModel) semanticObject); 
				return; 
			case AgentLangPackage.SUPPORT_REQUIREMENT:
				sequence_SupportRequirement(context, (SupportRequirement) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Move returns AttackExperiment
	 *     AttackExperiment returns AttackExperiment
	 *
	 * Constraint:
	 *     (experiment=[Experiment|ID] theory=Theory)
	 * </pre>
	 */
	protected void sequence_AttackExperiment(ISerializationContext context, AttackExperiment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AgentLangPackage.Literals.ATTACK_EXPERIMENT__EXPERIMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AgentLangPackage.Literals.ATTACK_EXPERIMENT__EXPERIMENT));
			if (transientValues.isValueTransient(semanticObject, AgentLangPackage.Literals.ATTACK_EXPERIMENT__THEORY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AgentLangPackage.Literals.ATTACK_EXPERIMENT__THEORY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAttackExperimentAccess().getExperimentExperimentIDTerminalRuleCall_2_0_1(), semanticObject.eGet(AgentLangPackage.Literals.ATTACK_EXPERIMENT__EXPERIMENT, false));
		feeder.accept(grammarAccess.getAttackExperimentAccess().getTheoryTheoryParserRuleCall_4_0(), semanticObject.getTheory());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Move returns AttackModel
	 *     AttackModel returns AttackModel
	 *
	 * Constraint:
	 *     (model=[Model|ID] theory=Theory)
	 * </pre>
	 */
	protected void sequence_AttackModel(ISerializationContext context, AttackModel semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AgentLangPackage.Literals.ATTACK_MODEL__MODEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AgentLangPackage.Literals.ATTACK_MODEL__MODEL));
			if (transientValues.isValueTransient(semanticObject, AgentLangPackage.Literals.ATTACK_MODEL__THEORY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AgentLangPackage.Literals.ATTACK_MODEL__THEORY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAttackModelAccess().getModelModelIDTerminalRuleCall_2_0_1(), semanticObject.eGet(AgentLangPackage.Literals.ATTACK_MODEL__MODEL, false));
		feeder.accept(grammarAccess.getAttackModelAccess().getTheoryTheoryParserRuleCall_4_0(), semanticObject.getTheory());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Move returns AttackRequirement
	 *     AttackRequirement returns AttackRequirement
	 *
	 * Constraint:
	 *     (requirement=[Requirement|ID] theory=Theory)
	 * </pre>
	 */
	protected void sequence_AttackRequirement(ISerializationContext context, AttackRequirement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AgentLangPackage.Literals.ATTACK_REQUIREMENT__REQUIREMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AgentLangPackage.Literals.ATTACK_REQUIREMENT__REQUIREMENT));
			if (transientValues.isValueTransient(semanticObject, AgentLangPackage.Literals.ATTACK_REQUIREMENT__THEORY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AgentLangPackage.Literals.ATTACK_REQUIREMENT__THEORY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAttackRequirementAccess().getRequirementRequirementIDTerminalRuleCall_2_0_1(), semanticObject.eGet(AgentLangPackage.Literals.ATTACK_REQUIREMENT__REQUIREMENT, false));
		feeder.accept(grammarAccess.getAttackRequirementAccess().getTheoryTheoryParserRuleCall_4_0(), semanticObject.getTheory());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Move returns CounterModel
	 *     CounterModel returns CounterModel
	 *
	 * Constraint:
	 *     (model=[Model|ID] experiment=Experiment requirement=[Requirement|ID])
	 * </pre>
	 */
	protected void sequence_CounterModel(ISerializationContext context, CounterModel semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AgentLangPackage.Literals.COUNTER_MODEL__MODEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AgentLangPackage.Literals.COUNTER_MODEL__MODEL));
			if (transientValues.isValueTransient(semanticObject, AgentLangPackage.Literals.COUNTER_MODEL__EXPERIMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AgentLangPackage.Literals.COUNTER_MODEL__EXPERIMENT));
			if (transientValues.isValueTransient(semanticObject, AgentLangPackage.Literals.COUNTER_MODEL__REQUIREMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AgentLangPackage.Literals.COUNTER_MODEL__REQUIREMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCounterModelAccess().getModelModelIDTerminalRuleCall_2_0_1(), semanticObject.eGet(AgentLangPackage.Literals.COUNTER_MODEL__MODEL, false));
		feeder.accept(grammarAccess.getCounterModelAccess().getExperimentExperimentParserRuleCall_4_0(), semanticObject.getExperiment());
		feeder.accept(grammarAccess.getCounterModelAccess().getRequirementRequirementIDTerminalRuleCall_6_0_1(), semanticObject.eGet(AgentLangPackage.Literals.COUNTER_MODEL__REQUIREMENT, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Experiment returns Experiment
	 *
	 * Constraint:
	 *     (name=ID content=STRING)
	 * </pre>
	 */
	protected void sequence_Experiment(ISerializationContext context, Experiment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AgentLangPackage.Literals.EXPERIMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AgentLangPackage.Literals.EXPERIMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, AgentLangPackage.Literals.EXPERIMENT__CONTENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AgentLangPackage.Literals.EXPERIMENT__CONTENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExperimentAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getExperimentAccess().getContentSTRINGTerminalRuleCall_2_0(), semanticObject.getContent());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Game returns Game
	 *
	 * Constraint:
	 *     moves+=Move+
	 * </pre>
	 */
	protected void sequence_Game(ISerializationContext context, Game semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Theory returns GeneralTheory
	 *     GeneralTheory returns GeneralTheory
	 *
	 * Constraint:
	 *     (name=ID content=STRING)
	 * </pre>
	 */
	protected void sequence_GeneralTheory(ISerializationContext context, GeneralTheory semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AgentLangPackage.Literals.THEORY__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AgentLangPackage.Literals.THEORY__NAME));
			if (transientValues.isValueTransient(semanticObject, AgentLangPackage.Literals.GENERAL_THEORY__CONTENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AgentLangPackage.Literals.GENERAL_THEORY__CONTENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGeneralTheoryAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getGeneralTheoryAccess().getContentSTRINGTerminalRuleCall_2_0(), semanticObject.getContent());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Theory returns LiteratureReference
	 *     LiteratureReference returns LiteratureReference
	 *
	 * Constraint:
	 *     (name=ID ref=STRING)
	 * </pre>
	 */
	protected void sequence_LiteratureReference(ISerializationContext context, LiteratureReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AgentLangPackage.Literals.THEORY__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AgentLangPackage.Literals.THEORY__NAME));
			if (transientValues.isValueTransient(semanticObject, AgentLangPackage.Literals.LITERATURE_REFERENCE__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AgentLangPackage.Literals.LITERATURE_REFERENCE__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLiteratureReferenceAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getLiteratureReferenceAccess().getRefSTRINGTerminalRuleCall_2_0(), semanticObject.getRef());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (name=ID content=STRING)
	 * </pre>
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AgentLangPackage.Literals.MODEL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AgentLangPackage.Literals.MODEL__NAME));
			if (transientValues.isValueTransient(semanticObject, AgentLangPackage.Literals.MODEL__CONTENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AgentLangPackage.Literals.MODEL__CONTENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getModelAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getModelAccess().getContentSTRINGTerminalRuleCall_2_0(), semanticObject.getContent());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Move returns NotConvinced
	 *     NotConvinced returns NotConvinced
	 *
	 * Constraint:
	 *     model=[Model|ID]
	 * </pre>
	 */
	protected void sequence_NotConvinced(ISerializationContext context, NotConvinced semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AgentLangPackage.Literals.NOT_CONVINCED__MODEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AgentLangPackage.Literals.NOT_CONVINCED__MODEL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNotConvincedAccess().getModelModelIDTerminalRuleCall_2_0_1(), semanticObject.eGet(AgentLangPackage.Literals.NOT_CONVINCED__MODEL, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Move returns ProposeExperiment
	 *     ProposeExperiment returns ProposeExperiment
	 *
	 * Constraint:
	 *     (model=[Model|ID] experiment=Experiment requirement=[Requirement|ID])
	 * </pre>
	 */
	protected void sequence_ProposeExperiment(ISerializationContext context, ProposeExperiment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AgentLangPackage.Literals.PROPOSE_EXPERIMENT__MODEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AgentLangPackage.Literals.PROPOSE_EXPERIMENT__MODEL));
			if (transientValues.isValueTransient(semanticObject, AgentLangPackage.Literals.PROPOSE_EXPERIMENT__EXPERIMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AgentLangPackage.Literals.PROPOSE_EXPERIMENT__EXPERIMENT));
			if (transientValues.isValueTransient(semanticObject, AgentLangPackage.Literals.PROPOSE_EXPERIMENT__REQUIREMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AgentLangPackage.Literals.PROPOSE_EXPERIMENT__REQUIREMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProposeExperimentAccess().getModelModelIDTerminalRuleCall_2_0_1(), semanticObject.eGet(AgentLangPackage.Literals.PROPOSE_EXPERIMENT__MODEL, false));
		feeder.accept(grammarAccess.getProposeExperimentAccess().getExperimentExperimentParserRuleCall_4_0(), semanticObject.getExperiment());
		feeder.accept(grammarAccess.getProposeExperimentAccess().getRequirementRequirementIDTerminalRuleCall_6_0_1(), semanticObject.eGet(AgentLangPackage.Literals.PROPOSE_EXPERIMENT__REQUIREMENT, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Move returns ProposeModel
	 *     ProposeModel returns ProposeModel
	 *
	 * Constraint:
	 *     (model=Model requirement=[Requirement|ID])
	 * </pre>
	 */
	protected void sequence_ProposeModel(ISerializationContext context, ProposeModel semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AgentLangPackage.Literals.PROPOSE_MODEL__MODEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AgentLangPackage.Literals.PROPOSE_MODEL__MODEL));
			if (transientValues.isValueTransient(semanticObject, AgentLangPackage.Literals.PROPOSE_MODEL__REQUIREMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AgentLangPackage.Literals.PROPOSE_MODEL__REQUIREMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProposeModelAccess().getModelModelParserRuleCall_2_0(), semanticObject.getModel());
		feeder.accept(grammarAccess.getProposeModelAccess().getRequirementRequirementIDTerminalRuleCall_4_0_1(), semanticObject.eGet(AgentLangPackage.Literals.PROPOSE_MODEL__REQUIREMENT, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Move returns ProposeRQ
	 *     ProposeRQ returns ProposeRQ
	 *
	 * Constraint:
	 *     rq=ResearchQuestion
	 * </pre>
	 */
	protected void sequence_ProposeRQ(ISerializationContext context, ProposeRQ semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AgentLangPackage.Literals.PROPOSE_RQ__RQ) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AgentLangPackage.Literals.PROPOSE_RQ__RQ));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProposeRQAccess().getRqResearchQuestionParserRuleCall_2_0(), semanticObject.getRq());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Move returns ProposeRequirement
	 *     ProposeRequirement returns ProposeRequirement
	 *
	 * Constraint:
	 *     (requirement=Requirement rq=[ResearchQuestion|ID])
	 * </pre>
	 */
	protected void sequence_ProposeRequirement(ISerializationContext context, ProposeRequirement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AgentLangPackage.Literals.PROPOSE_REQUIREMENT__REQUIREMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AgentLangPackage.Literals.PROPOSE_REQUIREMENT__REQUIREMENT));
			if (transientValues.isValueTransient(semanticObject, AgentLangPackage.Literals.PROPOSE_REQUIREMENT__RQ) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AgentLangPackage.Literals.PROPOSE_REQUIREMENT__RQ));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProposeRequirementAccess().getRequirementRequirementParserRuleCall_2_0(), semanticObject.getRequirement());
		feeder.accept(grammarAccess.getProposeRequirementAccess().getRqResearchQuestionIDTerminalRuleCall_4_0_1(), semanticObject.eGet(AgentLangPackage.Literals.PROPOSE_REQUIREMENT__RQ, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Move returns RedefineRequirement
	 *     RedefineRequirement returns RedefineRequirement
	 *
	 * Constraint:
	 *     (requirement=[Requirement|ID] newRequirement=Requirement)
	 * </pre>
	 */
	protected void sequence_RedefineRequirement(ISerializationContext context, RedefineRequirement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AgentLangPackage.Literals.REDEFINE_REQUIREMENT__REQUIREMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AgentLangPackage.Literals.REDEFINE_REQUIREMENT__REQUIREMENT));
			if (transientValues.isValueTransient(semanticObject, AgentLangPackage.Literals.REDEFINE_REQUIREMENT__NEW_REQUIREMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AgentLangPackage.Literals.REDEFINE_REQUIREMENT__NEW_REQUIREMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRedefineRequirementAccess().getRequirementRequirementIDTerminalRuleCall_2_0_1(), semanticObject.eGet(AgentLangPackage.Literals.REDEFINE_REQUIREMENT__REQUIREMENT, false));
		feeder.accept(grammarAccess.getRedefineRequirementAccess().getNewRequirementRequirementParserRuleCall_4_0(), semanticObject.getNewRequirement());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Move returns ReplaceModel
	 *     ReplaceModel returns ReplaceModel
	 *
	 * Constraint:
	 *     (model=[Model|ID] newModel=Model)
	 * </pre>
	 */
	protected void sequence_ReplaceModel(ISerializationContext context, ReplaceModel semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AgentLangPackage.Literals.REPLACE_MODEL__MODEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AgentLangPackage.Literals.REPLACE_MODEL__MODEL));
			if (transientValues.isValueTransient(semanticObject, AgentLangPackage.Literals.REPLACE_MODEL__NEW_MODEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AgentLangPackage.Literals.REPLACE_MODEL__NEW_MODEL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReplaceModelAccess().getModelModelIDTerminalRuleCall_2_0_1(), semanticObject.eGet(AgentLangPackage.Literals.REPLACE_MODEL__MODEL, false));
		feeder.accept(grammarAccess.getReplaceModelAccess().getNewModelModelParserRuleCall_4_0(), semanticObject.getNewModel());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Requirement returns Requirement
	 *
	 * Constraint:
	 *     (name=ID content=STRING? dataDescription=STRING)
	 * </pre>
	 */
	protected void sequence_Requirement(ISerializationContext context, Requirement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ResearchQuestion returns ResearchQuestion
	 *
	 * Constraint:
	 *     (name=ID effect=STRING)
	 * </pre>
	 */
	protected void sequence_ResearchQuestion(ISerializationContext context, ResearchQuestion semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AgentLangPackage.Literals.RESEARCH_QUESTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AgentLangPackage.Literals.RESEARCH_QUESTION__NAME));
			if (transientValues.isValueTransient(semanticObject, AgentLangPackage.Literals.RESEARCH_QUESTION__EFFECT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AgentLangPackage.Literals.RESEARCH_QUESTION__EFFECT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getResearchQuestionAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getResearchQuestionAccess().getEffectSTRINGTerminalRuleCall_6_0(), semanticObject.getEffect());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Move returns RetractExperiment
	 *     RetractExperiment returns RetractExperiment
	 *
	 * Constraint:
	 *     experiment=[Experiment|ID]
	 * </pre>
	 */
	protected void sequence_RetractExperiment(ISerializationContext context, RetractExperiment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AgentLangPackage.Literals.RETRACT_EXPERIMENT__EXPERIMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AgentLangPackage.Literals.RETRACT_EXPERIMENT__EXPERIMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRetractExperimentAccess().getExperimentExperimentIDTerminalRuleCall_2_0_1(), semanticObject.eGet(AgentLangPackage.Literals.RETRACT_EXPERIMENT__EXPERIMENT, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Move returns RetractRequirement
	 *     RetractRequirement returns RetractRequirement
	 *
	 * Constraint:
	 *     requirement=[Requirement|ID]
	 * </pre>
	 */
	protected void sequence_RetractRequirement(ISerializationContext context, RetractRequirement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AgentLangPackage.Literals.RETRACT_REQUIREMENT__REQUIREMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AgentLangPackage.Literals.RETRACT_REQUIREMENT__REQUIREMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRetractRequirementAccess().getRequirementRequirementIDTerminalRuleCall_2_0_1(), semanticObject.eGet(AgentLangPackage.Literals.RETRACT_REQUIREMENT__REQUIREMENT, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Move returns ReviseRequirement
	 *     ReviseRequirement returns ReviseRequirement
	 *
	 * Constraint:
	 *     (model=[Model|ID] requirement=[Requirement|ID] newRequirement=Requirement experiment=[Experiment|ID])
	 * </pre>
	 */
	protected void sequence_ReviseRequirement(ISerializationContext context, ReviseRequirement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AgentLangPackage.Literals.REVISE_REQUIREMENT__MODEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AgentLangPackage.Literals.REVISE_REQUIREMENT__MODEL));
			if (transientValues.isValueTransient(semanticObject, AgentLangPackage.Literals.REVISE_REQUIREMENT__REQUIREMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AgentLangPackage.Literals.REVISE_REQUIREMENT__REQUIREMENT));
			if (transientValues.isValueTransient(semanticObject, AgentLangPackage.Literals.REVISE_REQUIREMENT__NEW_REQUIREMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AgentLangPackage.Literals.REVISE_REQUIREMENT__NEW_REQUIREMENT));
			if (transientValues.isValueTransient(semanticObject, AgentLangPackage.Literals.REVISE_REQUIREMENT__EXPERIMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AgentLangPackage.Literals.REVISE_REQUIREMENT__EXPERIMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReviseRequirementAccess().getModelModelIDTerminalRuleCall_2_0_1(), semanticObject.eGet(AgentLangPackage.Literals.REVISE_REQUIREMENT__MODEL, false));
		feeder.accept(grammarAccess.getReviseRequirementAccess().getRequirementRequirementIDTerminalRuleCall_4_0_1(), semanticObject.eGet(AgentLangPackage.Literals.REVISE_REQUIREMENT__REQUIREMENT, false));
		feeder.accept(grammarAccess.getReviseRequirementAccess().getNewRequirementRequirementParserRuleCall_6_0(), semanticObject.getNewRequirement());
		feeder.accept(grammarAccess.getReviseRequirementAccess().getExperimentExperimentIDTerminalRuleCall_8_0_1(), semanticObject.eGet(AgentLangPackage.Literals.REVISE_REQUIREMENT__EXPERIMENT, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Move returns StudyDone
	 *     StudyDone returns StudyDone
	 *
	 * Constraint:
	 *     {StudyDone}
	 * </pre>
	 */
	protected void sequence_StudyDone(ISerializationContext context, StudyDone semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Move returns SupportExperiment
	 *     SupportExperiment returns SupportExperiment
	 *
	 * Constraint:
	 *     (experiment=[Experiment|ID] theory=Theory)
	 * </pre>
	 */
	protected void sequence_SupportExperiment(ISerializationContext context, SupportExperiment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AgentLangPackage.Literals.SUPPORT_EXPERIMENT__EXPERIMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AgentLangPackage.Literals.SUPPORT_EXPERIMENT__EXPERIMENT));
			if (transientValues.isValueTransient(semanticObject, AgentLangPackage.Literals.SUPPORT_EXPERIMENT__THEORY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AgentLangPackage.Literals.SUPPORT_EXPERIMENT__THEORY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSupportExperimentAccess().getExperimentExperimentIDTerminalRuleCall_2_0_1(), semanticObject.eGet(AgentLangPackage.Literals.SUPPORT_EXPERIMENT__EXPERIMENT, false));
		feeder.accept(grammarAccess.getSupportExperimentAccess().getTheoryTheoryParserRuleCall_4_0(), semanticObject.getTheory());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Move returns SupportModel
	 *     SupportModel returns SupportModel
	 *
	 * Constraint:
	 *     (model=[Model|ID] theory=Theory)
	 * </pre>
	 */
	protected void sequence_SupportModel(ISerializationContext context, SupportModel semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AgentLangPackage.Literals.SUPPORT_MODEL__MODEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AgentLangPackage.Literals.SUPPORT_MODEL__MODEL));
			if (transientValues.isValueTransient(semanticObject, AgentLangPackage.Literals.SUPPORT_MODEL__THEORY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AgentLangPackage.Literals.SUPPORT_MODEL__THEORY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSupportModelAccess().getModelModelIDTerminalRuleCall_2_0_1(), semanticObject.eGet(AgentLangPackage.Literals.SUPPORT_MODEL__MODEL, false));
		feeder.accept(grammarAccess.getSupportModelAccess().getTheoryTheoryParserRuleCall_4_0(), semanticObject.getTheory());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Move returns SupportRequirement
	 *     SupportRequirement returns SupportRequirement
	 *
	 * Constraint:
	 *     (requirement=[Requirement|ID] theory=Theory)
	 * </pre>
	 */
	protected void sequence_SupportRequirement(ISerializationContext context, SupportRequirement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AgentLangPackage.Literals.SUPPORT_REQUIREMENT__REQUIREMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AgentLangPackage.Literals.SUPPORT_REQUIREMENT__REQUIREMENT));
			if (transientValues.isValueTransient(semanticObject, AgentLangPackage.Literals.SUPPORT_REQUIREMENT__THEORY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AgentLangPackage.Literals.SUPPORT_REQUIREMENT__THEORY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSupportRequirementAccess().getRequirementRequirementIDTerminalRuleCall_2_0_1(), semanticObject.eGet(AgentLangPackage.Literals.SUPPORT_REQUIREMENT__REQUIREMENT, false));
		feeder.accept(grammarAccess.getSupportRequirementAccess().getTheoryTheoryParserRuleCall_4_0(), semanticObject.getTheory());
		feeder.finish();
	}
	
	
}
