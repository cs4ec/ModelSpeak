/**
 * generated by Xtext 2.35.0
 */
package uk.ac.kcl.inf.modelspeak.scoping;

import java.util.Arrays;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import uk.ac.kcl.inf.modelspeak.agentLang.CounterModel;
import uk.ac.kcl.inf.modelspeak.agentLang.Experiment;
import uk.ac.kcl.inf.modelspeak.agentLang.Game;
import uk.ac.kcl.inf.modelspeak.agentLang.Model;
import uk.ac.kcl.inf.modelspeak.agentLang.Move;
import uk.ac.kcl.inf.modelspeak.agentLang.ProposeExperiment;
import uk.ac.kcl.inf.modelspeak.agentLang.ProposeModel;
import uk.ac.kcl.inf.modelspeak.agentLang.ProposeRequirement;
import uk.ac.kcl.inf.modelspeak.agentLang.RedefineRequirement;
import uk.ac.kcl.inf.modelspeak.agentLang.ReplaceModel;
import uk.ac.kcl.inf.modelspeak.agentLang.Requirement;
import uk.ac.kcl.inf.modelspeak.agentLang.ReviseRequirement;
import uk.ac.kcl.inf.modelspeak.agentLang.SupportExperiment;
import uk.ac.kcl.inf.modelspeak.agentLang.SupportModel;
import uk.ac.kcl.inf.modelspeak.agentLang.SupportRequirement;

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
@SuppressWarnings("all")
public class AgentLangScopeProvider extends AbstractDeclarativeScopeProvider {
  public IScope scope_SupportRequirement_requirement(final SupportRequirement supportMove, final EReference ref) {
    IScope _xblockexpression = null;
    {
      EObject _eContainer = supportMove.eContainer();
      final Game game = ((Game) _eContainer);
      final Function1<Move, Boolean> _function = (Move it) -> {
        return Boolean.valueOf((it != supportMove));
      };
      final Iterable<Move> moves = IterableExtensions.<Move>takeWhile(game.getMoves(), _function);
      final Function1<Move, Requirement> _function_1 = (Move it) -> {
        return this.getReq(it);
      };
      _xblockexpression = Scopes.scopeFor(IterableExtensions.<Requirement>filterNull(IterableExtensions.<Move, Requirement>map(moves, _function_1)));
    }
    return _xblockexpression;
  }

  protected Requirement _getReq(final Move m) {
    return null;
  }

  protected Requirement _getReq(final ReviseRequirement m) {
    return m.getNewRequirement();
  }

  protected Requirement _getReq(final ProposeRequirement m) {
    return m.getRequirement();
  }

  protected Requirement _getReq(final RedefineRequirement m) {
    return m.getNewRequirement();
  }

  public IScope scope_SupportModel_model(final SupportModel supportMove, final EReference ref) {
    IScope _xblockexpression = null;
    {
      EObject _eContainer = supportMove.eContainer();
      final Game game = ((Game) _eContainer);
      final Function1<Move, Boolean> _function = (Move it) -> {
        return Boolean.valueOf((it != supportMove));
      };
      final Iterable<Move> moves = IterableExtensions.<Move>takeWhile(game.getMoves(), _function);
      final Function1<Move, Model> _function_1 = (Move it) -> {
        return this.getModel(it);
      };
      _xblockexpression = Scopes.scopeFor(IterableExtensions.<Model>filterNull(IterableExtensions.<Move, Model>map(moves, _function_1)));
    }
    return _xblockexpression;
  }

  protected Model _getModel(final Move m) {
    return null;
  }

  protected Model _getModel(final ProposeModel m) {
    return m.getModel();
  }

  protected Model _getModel(final ReplaceModel m) {
    return m.getNewModel();
  }

  public IScope scope_SupportExperiment_experiment(final SupportExperiment supportMove, final EReference ref) {
    IScope _xblockexpression = null;
    {
      EObject _eContainer = supportMove.eContainer();
      final Game game = ((Game) _eContainer);
      final Function1<Move, Boolean> _function = (Move it) -> {
        return Boolean.valueOf((it != supportMove));
      };
      final Iterable<Move> moves = IterableExtensions.<Move>takeWhile(game.getMoves(), _function);
      final Function1<Move, Experiment> _function_1 = (Move it) -> {
        return this.getExperiment(it);
      };
      _xblockexpression = Scopes.scopeFor(IterableExtensions.<Experiment>filterNull(IterableExtensions.<Move, Experiment>map(moves, _function_1)));
    }
    return _xblockexpression;
  }

  protected Experiment _getExperiment(final Move m) {
    return null;
  }

  protected Experiment _getExperiment(final CounterModel m) {
    return m.getExperiment();
  }

  protected Experiment _getExperiment(final ProposeExperiment m) {
    return m.getExperiment();
  }

  public Requirement getReq(final Move m) {
    if (m instanceof ProposeRequirement) {
      return _getReq((ProposeRequirement)m);
    } else if (m instanceof RedefineRequirement) {
      return _getReq((RedefineRequirement)m);
    } else if (m instanceof ReviseRequirement) {
      return _getReq((ReviseRequirement)m);
    } else if (m != null) {
      return _getReq(m);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(m).toString());
    }
  }

  public Model getModel(final Move m) {
    if (m instanceof ProposeModel) {
      return _getModel((ProposeModel)m);
    } else if (m instanceof ReplaceModel) {
      return _getModel((ReplaceModel)m);
    } else if (m != null) {
      return _getModel(m);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(m).toString());
    }
  }

  public Experiment getExperiment(final Move m) {
    if (m instanceof CounterModel) {
      return _getExperiment((CounterModel)m);
    } else if (m instanceof ProposeExperiment) {
      return _getExperiment((ProposeExperiment)m);
    } else if (m != null) {
      return _getExperiment(m);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(m).toString());
    }
  }
}
